
一、volatile关键字：Java编程语言允许线程访问共享变量，为了确保共享变量能够准确一致的更新，线程确保通过排它锁单独获得这个变量。

    1、Java虚拟机把Java源代码编译成.class字节码文件，然后class文件加载到内存，JVM执行字节码，最终转化为汇编指令在CPU上执行。

    2、CPU术语：
    内存屏障：是一组处理器指令，用于实现内存操作的顺序限制。
    缓存行：缓存中可以分配的最小单位。
    原子操作：不可中断的一系列操作。
    缓存行填充：当处理器识别到从内存中读取的操作数可以是缓存的，处理器读取整个缓存行到适当的缓存。

    3、可见性：当线程修改一个共享变量的时候，另外一个线程能够读到这个修改后的值。
        当一个变量被声明为volatile的时候，处理器底层的行为：
        3.1、将当前处理器缓存行的数据写回到系统内存中。
           如何写？
            缓存锁定的方式保证原子性，如果执行的写操作的内存区域已经缓存在处理器的内部，就会锁定这块缓存的区域并写回到内存，并使用缓存一致性协议确保修改的原子性。
        3.2、这个写回到内存的数据会使得其他CPU里缓存了该内存地址的数据无效。
           如何使其他CPU缓存失效？
            修改、独占、共享、无效；处理器通过嗅探技术得知其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器会把缓存行设置为无效。

    4、防止指令重排：


二、synchronized关键字
    1、同步代码块：锁括号里面的配置对象
    2、同步方法：锁当前实例对象
    3、同步静态方法：锁当前类的class对象


    JVM通过一个监视器对象实现对代码块的同步，对应的指令是monitorenter和monitorexit，方法的同步是另一种机制，但是仍然使用的是监视器来实现同步。
    具体是：monitorenter指令插入到同步代码块的开始位置，而monitorexit则被插入到方法结束和异常处。任何对象都有一个监视器对象与之关联，当一个监视器对象被持有的时候该对象将处于锁定状态。
    当线程执行到monitorenter时，将尝试获取对象所对应的监视器对象的所有权，也就是线程的锁。

三、锁的使用
    锁的状态：无锁，偏向锁，轻量级锁，重量级锁
    1、偏向锁：
        之所以引入偏向锁是为了让获取锁的代价更低。当一个线程访问同步代码块并获取锁的时候，会在对象的对象头和栈帧中的锁记录中存储锁偏向的ID，以后该线程再进入方法的同步块的时候，
        就检查这个ID，如果测试成功，表明对象已经获得了锁；如果测试失败，继续测试偏向锁的标志是否为1，1的话就是偏向锁，否则使用CAS锁。

        特点，在竞争激烈的场合性能差，大量的竞争导致持有锁的线程不停的切换，锁很难保持偏向模式。适用于只有一个线程方法同步块的情况。

    2、轻量级锁
        如果偏向锁失败，Java虚拟机就会让线程申请轻量级锁，轻量级锁在虚拟机内部，使用一个称为BasicObjectLock的对象实现的，这个对象内部由一个BasicLock对象和一个持有该锁的Java对象
        指针组成。BasicObjectLock对象放置在Java栈帧中。在BasicLock对象内部还维护着displaced_header字段，用于备份对象头部的Mark Word.

        当一个线程持有一个对象的锁的时候，对象头部Mark Word信息如下

        [ptr                       |00] locked

        末尾的两位比特为00，整个Mark Word为指向BasicLock对象的指针。由于BasicObjectLock对象在线程栈中，因此该指针必然指向持有该锁的线程栈空间。当需要判断一个线程是否持有该对象时，
        只需要简单地判断对象头的指针是否在当前线程的栈地址范围即可。同时，BasicLock对象的displaced_header，备份了原对象的Mark word内容，BasicObjectLock对象的obj字段则指向持有锁
        的对象头部。

        2.1 加锁
             当线程执行到同步块之前，JVM首先会检查当前线程的栈桢中创建用于存储记录锁记录的空间，并将对象头中的Mark Word复制到锁记录中，也称为Displaced Mark Word，然后线程尝试使用CAS将
            对象头中的Mark Word替换为指向锁记录的指针。如果成功，则线程获得锁，否则当前线程尝试使用自旋获得锁。
        2.2 解锁
             使用CAS操作将Displaced Mark Word替换回对象头，如果成功，则表示没有发生竞争。如果失败 则表示当前锁存在竞争，锁就会膨胀，膨胀的结果是导致锁的升级，进入阻塞状态。直到需要释放
            锁的线程释放锁，并唤起其他等待的线程。
        2.3 CAS （compare and swap 比较和替换)
             当进行CAS操作的时候，需要输入两个值，一个原来的值，一个即将发生改变的值，在CAS操作期间会去比较原值是否发生变化，如果没有发生变化就用新值替换原值，否则不替换。

        适用于追求响应时间的情况。

    3、重量级锁
        当轻量级锁失败，虚拟机就会使用重量级锁，在使用重量级锁时，对象的Mark Word如下：
        [ptr                     |10]  monitor
        重量级锁在操作过程中，线程可能会被操作系统层面挂起，如果是这样线程间的切换调用成本就会大大增加。

    4、自旋锁
        自旋锁可以使线程在没有获得锁的时候，不被挂起，而去执行一个空循环。在若干空循环后如果获得锁，则继续执行，若依然不能获得锁则被挂起。
        适用于锁竞争不是很激烈，锁占用时间很短的并发线程。





